#!/usr/bin/env ruby
# coding: utf-8

require 'yaml'
require 'json'
require 'set'

require_relative 'bgi_decompiler'

require_relative 'converter_common'

class Bgi2StoryConverter
  include ExplicitChars

  def initialize(fn, meta, chars, script_name)
    @meta = meta
    @chars = chars
    @script_name = script_name

    @decom = BGIDecompiler.new(fn)

    @out = []
    @imgs = {}

    @voice_seq = {}
    @layers = Set.new
  end

  def out
    {
      'meta' => @meta,
      'imgs' => @imgs,
      'chars' => @chars,
      'script' => @out,
    }
  end

  def simplify(v)
    if v.is_a?(BGIDecompiler::Mul)
      simplify(v.a1) * simplify(v.a2)
    else
      v
    end
  end

  def run

    @decom.each { |addr, filename, line_num, op, args|
      # Convert Mul(x, -1) to just "-x"
      args.map! { |a| simplify(a) }

      if op.is_a?(String)
        meth_name = "op_#{op}"
        if respond_to?(meth_name)
          send(meth_name, args)
        else
          warn "not implemented: #{meth_name} #{args.inspect}"
        end
      elsif op.is_a?(Array)
        op_call(op[1], args)
      end
    }
  end

  def op_call(sub_name, args)
    warn "op_call: #{sub_name} #{args.inspect}"
  end
  
  # [1, 1, 0, " ", "Now, it was finally the day of our date."]
  def op_say(args)
    expect_arg_count(args, 5)
    expect_arg(args, 0, 1)
    expect_arg(args, 1, 1)
    expect_arg(args, 2, 0)
    _, _, _, char, txt = args

    # ' ' is used as narrator in Edelweiss Eiden Fantasia
    # 0 is used as narrator in Aiyoku no Eustia
    if char == ' ' or char == 0
      @out << {
        'op' => 'narrate',
        'txt' => {'en' => txt},
      }
    else
      ch = get_char_by_name(char)
      raise "unknown character: #{char.inspect}, got #{orig_to_char.inspect}" unless ch

      voice_ch = ch['voice']
      seq = @voice_seq[voice_ch] || 0
      seq += 1
      @voice_seq[voice_ch] = seq

      voice_fn = sprintf("voice/%s%s%03d0.ogg", voice_ch, @script_name, seq)

      if (txt[0] == '"' and txt[-1] == '"') or (txt[0] == '「' and txt[-1] == '」')
        txt = txt[1..-2]
        @out << {
          'op' => 'say',
          'char' => ch,
          'txt' => {'en' => txt},
          'voice' => voice_fn,
        }
      elsif txt[0] == '(' and txt[-1] == ')'
        txt = txt[1..-2]
        @out << {
          'op' => 'think',
          'char' => ch,
          'txt' => {'en' => txt},
          'voice' => voice_fn,
        }
      else
        raise "unable to remove quotes: #{txt.inspect}"
      end
    end

    @out << {'op' => 'keypress'}
  end

  def op_bg(args)
    expect_arg_count(args, 2)
    fade_time, fn = args

    @out << {'op' => 'img', 'layer' => 'bg', 'fn' => "data02000.arc/#{fn}.png"}
  end

  # [1000, 0, 0, "mask001", "20vacantdlo"]
  def op_bg_transition(args)
    expect_arg_count(args, 5)
    fade_time, a1, a2, mask_fn, fn = args
    (1..2).each { |i| expect_arg(args, i, 0) }

    @out << {'op' => 'img', 'layer' => 'bg', 'fn' => "data02000.arc/#{fn}.png"}
  end

  #sprite [1, 200, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "sak_25_bl_m", 0]
  def op_sprite(args)
    expect_arg_count(args, 16)

    has_lip_sync = args[0] # 0 or 1
    timeout = args[1]
    z = args[2]

    (3..12).each { |i| expect_arg(args, i, 0) }

    x_pos = args[13]

    fn = args[-2]
    layer_id = args[-1]

    h = {
      'layer' => layer_id,
      'fn' => "data02000.arc/#{fn}.png",
      'x' => x_pos,
      'z' => z + 100,
    }

    if @layers.include?(layer_id)
      # TODO: enable after implementation of regular images transfading
      #h['op'] = 'anim'
      #h['t'] = timeout
      h['op'] = 'img'
      @out << h
    else
      h['op'] = 'img'
      h['a'] = 0
      @out << h
      @out << {
        'op' => 'anim',
        'layer' => layer_id,
        'a' => 1,
        't' => timeout,
      }
    end

    @layers << layer_id
  end

  # [1, 200, 0, 0, 0, 0, 0, 1]
  def op_sprite_hide(args)
    expect_arg_count(args, 8)
    a0 = args[0] # 0 or 1
    timeout = args[1]
    (2..6).each { |i| expect_arg(args, i, 0) }
    layer_id = args[7]

    @out << {
      'op' => 'anim',
      'layer' => layer_id,
      'a' => 0,
      't' => timeout,
    }

    @layers.delete(layer_id)
  end

  # [0, 200]
  def op_sprite_hide_all(args)
    raise "unable to parse: #{args.inspect}" unless args == [0, 200]
    timeout = args[1]

    @layers.each { |layer_id|
      @out << {
        'op' => 'anim',
        'layer' => layer_id,
        'a' => 0,
        't' => timeout,
      }
    }
    @layers.clear
  end

  # [1000]
  def op_wait(args)
    expect_arg_count(args, 1)
    @out << {'op' => 'wait', 't' => args[0]}
  end

  # [2000, 100, "sel0340", 1]
  # [0, 100, "BGM011", 3]
  # [0, 100, "bw0010", 1]
  # [2000, 120, "selp0030", 0]
  def op_sound(args)
    expect_arg_count(args, 4)
    time_mark, vol, fn, channel = args

    fn.downcase!

    case fn
    when /^se[^l]/
      dst_fn = "se/#{fn}.ogg"
      is_loop = false
    else
      dst_fn = "sound/#{fn}.ogg"
      is_loop = true
    end

    @out << {
      'op' => 'sound_play',
      'fn' => dst_fn,
      'loop' => is_loop,
    }
  end

  # ["1010", 0]
  def op_set_script_file(args)
    expect_arg_count(args, 2)
    expect_arg(args, 1, 0)
    @script_name = args[0]
  end

  def expect_arg_count(args, n)
    raise "expected #{n} arguments, but there is #{args.count} - see #{args.inspect}" unless args.count == n
  end

  def expect_arg(args, i, val)
    raise "argument #{i} must be #{val.inspect}, it it is #{args[i].inspect} - see #{args.inspect}" unless args[i] == val
  end
end

if ARGV.size != 4
  puts "Usage: bgi2story <meta.yaml> <characters.yaml> <in_script> <out_story>"
  exit 1
end

meta_fn, chars_fn, in_script, out_story = ARGV

cnv = Bgi2StoryConverter.new(
  in_script,
  YAML.load(File.read(meta_fn)),
  YAML.load(File.read(chars_fn)),
  nil
)

cnv.run

File.open(out_story, 'w') { |out|
  out.print "program = "
  out.puts JSON.pretty_generate(cnv.out)
}
